<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ninja Comms – Secure Communication</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
  margin: 0;
  padding: 0;
  background: black;
  overflow: hidden;
  width: 100%;
  height: 100%;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}

#gl {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
}

.content {
  position: relative;
  z-index: 1;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  color: #dff;
  padding: 40px 20px;
  box-sizing: border-box;
}

.logo {
  max-width: 260px;
  width: 65%;
  height: auto;
  margin-bottom: 36px;
}

h1 {
  font-size: 3em;
  margin: 0 0 16px;
  font-weight: 600;
}

.description {
  font-size: 1.25em;
  max-width: 680px;
  line-height: 1.5;
  opacity: 0.9;
}

@media (max-width: 768px) {
  h1 { font-size: 2.4em; }
  .description { font-size: 1.1em; }
  .logo { max-width: 220px; }
}
</style>
</head>

<body>

<canvas id="gl"></canvas>

<div class="content">
  <img src="assets/app_icon_ninja_transparent.png"
       alt="Ninja Comms Logo"
       class="logo">

  <h1>Ninja Comms</h1>
  <div class="description">
    Secure communication layer
  </div>
</div>

<script>
/* ================= WEBGL MATRIX RAIN ================= */

const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl");

if (!gl) {
  alert("WebGL non disponibile");
}

/* Stato WebGL corretto */
gl.disable(gl.DEPTH_TEST);
gl.clearColor(0.0, 0.0, 0.0, 1.0);

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener("resize", resize);
resize();

/* Vertex shader */
const vertexShaderSource = `
attribute vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

/* Fragment shader – Matrix rain */
const fragmentShaderSource = `
precision highp float;
uniform vec2 iResolution;
uniform float iTime;

float rand(vec2 co) {
  return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
  vec2 uv = gl_FragCoord.xy / iResolution.xy;
  uv.x *= iResolution.x / iResolution.y;

  float columns = 90.0;
  vec2 id = floor(vec2(uv.x * columns, uv.y * columns));

  float speed = mix(0.2, 0.7, rand(vec2(id.x, 0.0)));
  float y = fract(uv.y + iTime * speed + rand(vec2(id.x)));

  float tail = smoothstep(0.0, 0.4, y) * (1.0 - y);
  float head = smoothstep(0.0, 0.05, y);

  float brightness = tail + head * 2.5;
  vec3 color = vec3(0.0, 1.0, 0.35) * (brightness + 0.15);

  gl_FragColor = vec4(color, 1.0);
}
`;

function compile(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

const program = gl.createProgram();
gl.attachShader(program, compile(gl.VERTEX_SHADER, vertexShaderSource));
gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fragmentShaderSource));
gl.linkProgram(program);
gl.useProgram(program);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),
  gl.STATIC_DRAW
);

const position = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(position);
gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

const resLoc = gl.getUniformLocation(program, "iResolution");
const timeLoc = gl.getUniformLocation(program, "iTime");

function render(time) {
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform2f(resLoc, canvas.width, canvas.height);
  gl.uniform1f(timeLoc, time * 0.001);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>

</body>
</html>
